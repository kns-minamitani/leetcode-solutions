# leetcode-solutions
このリポジトリは、私がLeetCodeの問題を解きながらアルゴリズムに関する能力を鍛えるための記録です。
主にコーディング面接対策と問題解決能力の向上を目的とし、まずは毎日コードを書くことに慣れるところから始めます。

LeetCode開始：2025/11/24
GitHubへの記録開始：2025/12/09
言語：Python3

フォルダをleetcodeの難易度別に分ける。
'retry'には解き直した問題を入れていく。

メモ
enumerate()
    for i, j in enumerate(list):
    --> i==index, j==content
    ex. l = [1,2,3]
        for i, j in enumerate(l):
            print(i,j**2)
        # 0 1
        # 1 4
        # 2 9

排他的論理和 '^'
    数字で使うと重複を排除することができる。
    ex. True^True or False^False = False
        True^False = True
        1^3^3 = 1
        * 3^6 = (11)_2 ^ (110)_2 = (101)_2 = 5

chr(int)
    入力した数字をUnicodeでそれに対応する文字に変換する。
    ex. chr(65) = 'A', chr(97) = 'a'
        chr(48) = '0', chr(57) = '9'
        chr(32) = ' ', chr(33) = '!'
        chr(9) = '\t', chr(10) = '\n'

ord(str)
     入力した文字を対応するUnicodeの数字に変換する。
    ex. ord('A') = 65, ord('1') = 49
        ord('あ') = 12354, ord('数') = 25968

int型のビットを操作する。
    '>>'：ビットを指定した桁数だけ右シフトする（末尾が消える）、'<<'：ビットを指定した桁数だけ左シフトする（末尾に0が増える）
    左右に対して、'&'：どちらも1なら1を返す。'|'：どちらかが1なら1を返す。
    ex. 5 >> 1 = 2 (101 -> 10)_2
        2 << 2 = 8 (10 -> 1000)_2
        10 & 3 = 2 (1010 & 0011 -> 0010)_2
        10 | 3 = 11 (1010 | 0011 -> 1011)_2

dict.get(key, DefaultValue)
    dict内の指定したkeyの値にアクセスできる。
    もし該当するkeyが存在しない場合、dict[key]=DefaultValueとして自動的に穴を埋めてくれる。
    ex. dict = {a:1}　とすると
        dict.get(a, 0) = 1 ,,,keyが存在するので値を表示してくれる
        dict.get(b, 0) = 0 ,,,keyが存在しないのでDefaultValueを設定した状態で表示してくれる

ビットマスク(偶数桁)
    "0x55555555"を使うと、32bit版の偶数桁のビットマスクとしてはたらく。
    "0x"は16進数で表記するという印、その時の5をビットに直すと0101なので偶数位置マスクとして使える。
    ex. 8 & 0x55555555 = (1000 & 01010101010101010101010101010101)_2 = 0
        9 & 0x55555555 = (1001 & 01010101010101010101010101010101)_2 = 1
        LeetCode no.342　参照